#!/usr/bin/env python
# -*- coding: utf-8; fill-column: 120 -*-
#
# This file is part of JK Python extensions
# Copyright (C) 2009 Jochen Küpper <software@jochen-kuepper.de>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# If you use this programm for scientific work, you must correctly reference it; see LICENSE file for details.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
from __future__ import division

"""Linearize a data-set based on an accompanying set of marker

Copyright (C) 2010 Jochen Küpper"""

__author__ = "Jochen Küpper <software@jochen-kuepper.de>"

import getopt, sys
import numpy
import scipy
import scipy.interpolate


def usage():
    print "jkext_linearize [-d distance] [-f fsr] [-o output_file] data marker"
    print "\nAll frequencies are in Hz"



def main(args):
    try:
        opts, args = getopt.getopt(args, "hd:f:o:", ["help"])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    # default values
    fsr = 300e6
    step = 1e6
    outfile = sys.stdout
    # scan commandline
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o == "-d":
            step = float(a)
        elif o == "-f":
            fsr = float(a)
        elif o == "-o":
            outfile_name = a
        else:
            assert False, "unhandled commandline option"
    # read data (intensities and marker positions)
    dataname = args[0]
    markername = args[1] + ".linear", 'w')
    # write results
    numpy.savetxt(outfile_orig, orig)
    numpy.savetxt(outfile_lin, linear)


if __name__ == "__main__":
    main(sys.argv[1:])
