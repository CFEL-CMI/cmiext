#!/usr/bin/env python
# -*- coding: utf-8; fill-column: 120 -*-
#
# This file is part of JK Python extensions
# Copyright (C) 2010 Jochen Küpper <software@jochen-kuepper.de>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# If you use this programm for scientific work, you must correctly reference it; see LICENSE file for details.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
from __future__ import division

"""Linearize a data-set based on an accompanying set of marker

Copyright (C) 2010 Jochen Küpper"""

__author__ = "Jochen Küpper <software@jochen-kuepper.de>"

import getopt, sys
import os.path
import struct
import numpy
import scipy
import scipy.interpolate


def usage():
    print "jkext_linearize [-a|--absolute=pos:freqeuncy] [-d distance] [-f fsr] [-o output_basename] [--pitt] [--square] data marker"
    print
    print "All frequencies are in Hz"



def load_text(filename, square=False):
    """Read data from an pure text file, with one column of intensities"""
    data = numpy.loadtxt(filename)
    if square:
        data = (data**2)
    return data



def load_PittMASSCOMP(filename, square=False):
    """Read binary data from the Pitt MASSCOMP data acquisition system (1980s and 90s)

    The original PMT data record is stored as
        compact = (short)(sqrt( counts ) * 2**5)
    to keep numbers within signed short integer for counts to 1M.  So, to restore to a linear scale, use
        counts = compact * compact / 2**10
    This calculation is performed when square==True.

    All other traces are stored as simple ADC values and are read out straight, if square=False.
    """
    bytes = open(filename, "rb").read()
    data = numpy.array(struct.unpack(">%dH" % (len(bytes)/2,), bytes))
    if square:
        data = (data**2) / 2**10
    return data



def main(args):
    try:
        opts, args = getopt.getopt(args, "a:d:f:ho:", ["absolute", "fsr", "help", "plot", "pitt", "square"])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    # default values
    abs_point = 0
    abs_freq = 0
    create_plot = False
    fsr = 300e6
    load_intensity = load_text
    outfile = sys.stdout
    square = False
    step = 1e6
    # scan commandline
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-a", "--absolute"):
            point, freq = a.split(':')
            abs_point = int(point)
            abs_freq = float(freq)
        elif o == "-d":
            step = float(a)
        elif o in ("-f", "--fsr"):
            fsr = float(a)
        elif o == "-o":
            outfile_name = a
        elif o == "--plot":
            create_plot = True
        elif o == "--pitt":
            load_intensity = load_PittMASSCOMP
        elif o == "--square":
            square = True
        else:
            assert False, "unhandled commandline option"
    # read data (intensities and marker positions)
    dataname = args[0]
    markername = args[1]
    data = load_intensity(dataname, square)
    marker = numpy.loadtxt(markername, dtype=numpy.int64)
    if marker[0] > abs_point:
        print "iodine calibration outside valid range"
        abs_point = marker[0]
        abs_freq = 0
    # create marker interpolation
    marker_frequencies = numpy.cumsum(numpy.ones(marker.shape) * fsr)
    frequency = scipy.interpolate.interp1d(marker, marker_frequencies, kind='cubic', copy=False, bounds_error=True)
    # create frequencies and intensities of data points for defined range
    freq = numpy.zeros((marker[-1]-marker[0]+1))
    inten = numpy.zeros((marker[-1]-marker[0]+1))
    for i in range(marker[0], marker[-1]+1, 1):
        inten[i - marker[0]] = data[i]
        freq[i - marker[0]]  = frequency(i)
        # print>>outfile_orig, freq[i - marker[0]], inten[i - marker[0]]
    # create spectrum interpolation
    intensity = scipy.interpolate.interp1d(freq, inten, kind='linear', copy=False, bounds_error=False, fill_value=0.)
    # create equidistant spectrum
    linear = numpy.ones(((freq[-1]-freq[0])/step, 2))
    linear[:,0] = numpy.cumsum(linear[:,0]*step)
    linear[:,1] = intensity(linear[:,0])
    # shift frequencies according to iodine calibration
    shift = abs_freq - freq[abs_point]
    orig = numpy.array(zip(freq - shift, inten))
    linear[:,0] -= shift
    # open output files
    root, ext = os.path.splitext(outfile_name)
    outfile_orig = file(root + ".orig" + ext, 'w')
    outfile_lin = file(root + ".linear" + ext, 'w')
    # write results
    numpy.savetxt(outfile_orig, orig)
    numpy.savetxt(outfile_lin, linear)
    # create plot
    if create_plot:
        import matplotlib.pyplot as plt
        plt.figure(1)
        plt.plot(orig[:,0], orig[:,1])
        plt.plot(linear[:,0], linear[:,1])
        plt.savefig(root + ".orig.eps")



if __name__ == "__main__":
    if len(sys.argv) < 1:
        usage()
        sys.exit(1)
    main(sys.argv[1:])
