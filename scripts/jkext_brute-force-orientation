#!/usr/bin/env python
# -*- coding: utf-8; fill-column: 120 -*-
#
# This file is part of JK Python extensions
# Copyright (C) 2009 Frank Filsinger
# Copyright (C) 2009 Jochen KÃ¼pper <software@jochen-kuepper.de>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later
# version.
#
# If you use this programm for scientific work, you must correctly reference it; see LICENSE file for details.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program. If not, see
# <http://www.gnu.org/licenses/>.
#
# some SGE commands for batch usage convenience
#$ -cwd
#$ -e $JOB_NAME.sge
#$ -o $JOB_NAME.sge
#$ -S $HOME/.python/bin/python
#$ -V
from __future__ import division

"""Calculate brute force orientation for ensemble of asymmetric top molecules"""

__author__ = "Frank Filsinger"
__version__ = "1.0 (02.03.2009)"

import getopt, sys
import math
import numpy

import jkext.molecule as molecule
from jkext.convert import *
from jkext.state import State


def create_population(temperature, Jmax):
    """create thermal population for |temperature| up to |Jmax|"""
    pass


def read_population(name):
    """read population from file |name|"""
    pop = []
    for line in file(name):
        J, Ka, Kc, M, p = line.split()
        pop.append((State(int(J), int(Ka), int(Kc), int(M)), p))
    return pop


def usage():
    # ToDo implement a useful usage description
    print "See script for details"


def main(args):
    try:
        opts, args = getopt.getopt(args[1:], "hT:p:", ["help", "temperature=", "Jmax=", "population="])
    except getopt.GetoptError, err:
        # print help information and exit:
        print str(err) # will print something like "option -a not recognized"
        usage()
        sys.exit(2)
    # default values
    thermal = False
    nonthermal = False
    temperature = 1. # K
    Jmax = 10
    # scan commandline
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o in ("-T", "--temperature"):
            thermal = True
            temperature = float(a)
        elif o in ("-p", "--population"):
            nonthermal = True
            population = read_population(a)
        elif o == "--Jmax":
            Jmax = int(a)
        else:
            assert False, "unhandled commandline option"

    if thermal == nonthermal:
        assert False, "commandline parsing resulted in thermal == nonthermal; stopping"

    if thermal == True:
        population = create_population(temperature, Jmax)


    for p in population:
        print p[0].name(), p[1]

    sys.exit(0)


    for state in statesfile:
       state = state[:-1]
       components = state.split(" ")
       filename = directory+"IB-"+components[0]+"-"+components[1]+"-"+components[2]+"-"+components[3]+"-stark.dat"
       weight = components[4]
       states.append([filename,weight])
    # loop over temperatures
    for i in range(len(temperature)):
       weight_sum = 0.0
       costheta_sum = 0.0
       for n in range(len(states)):
           print "file " + states[n][0] + "weight " + states[n][1]
           starkfile = file(states[n][0])
           datapoints = []
           for zeile in starkfile:
               zeile = zeile[:-1]
               datapoints.append(zeile)
                   #print "number of datapoints in file: ", len(datapoints)
                   #print " first line ", datapoints[1]
                   #print " last line ", datapoints[251]
           datafree = datapoints[1].split(" ")
           data250 = datapoints[251].split(" ")
                   # get field-free energy for this state
           energy = cm2J * float(datafree[3])
                   # get effective dipole moment for given field strength
           mueff = float(data250[6])
           #w = nssw * degen * math.exp(-energy/(boltzmann*temperature[i]))
           w = float(states[n][1])
           weight_sum = weight_sum + w
           costheta = mueff/dipole
           costheta_sum = costheta_sum + w*costheta
           print "field-free energy: ", datafree[3], " mueff @ 250 kV/cm: ", data250[6], " cos ", costheta
       print str(weight_sum)+" "+str(costheta_sum)+" "+str(costheta_sum/weight_sum)


if __name__ == "__main__":
    main(sys.argv)
